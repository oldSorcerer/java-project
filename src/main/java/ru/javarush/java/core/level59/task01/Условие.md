
### Параллельное чтение частей большого файла

Представьте, что вы — археолог данных, и вам предстоит расшифровать огромный древний свиток, содержащий ценные знания, или, возможно, это гигантский лог-файл с данными вашей космической станции! Этот файл data.bin настолько велик, что прочитать его в одиночку займёт целую вечность. Чтобы справиться с задачей быстро и эффективно, вы решаете привлечь команду помощников, каждый из которых займётся своим куском свитка.

Ваша задача — создать специального "читателя фрагментов" под названием ScrollFragmentReader, который будет реализовать интерфейс Runnable. Этот читатель должен уметь погружаться в определённое место свитка (стартовая позиция) и считывать заданный объём информации (размер фрагмента), которые вы передадите ему прямо при создании. Как только он завершит свою работу, пусть гордо сообщает: "Собран фрагмент свитка с позиции [стартовая_позиция] размером [размер_фрагмента] байт!".

Затем, в главном центре управления (main методе), представьте, что вы делите этот колоссальный data.bin на четыре совершенно равные части. Для организации работы вашей "команды археологов" используйте мощный ExecutorService, настроенный на 4 одновременных потока. Запустите каждого "читателя фрагментов", чтобы они параллельно приступили к своей части свитка. Цель — убедиться, что весь свиток будет просмотрен быстро, а каждый помощник отчитается о проделанной работе.

#### Требования:
1. Необходимо создать класс ScrollFragmentReader, который реализует интерфейс Runnable.
2. Класс ScrollFragmentReader должен иметь конструктор, принимающий два параметра: стартовую позицию (long) и размер фрагмента (int/long).
3. В методе run класса ScrollFragmentReader необходимо открыть файл data.bin, перейти к указанной стартовой позиции и прочитать заданное количество байт.
4. В методе main нужно создать ExecutorService с фиксированным пулом из четырёх потоков для параллельного выполнения задач.
5. В методе main необходимо определить размер файла data.bin и разделить его на четыре равных по размеру части (последняя часть может быть чуть больше при нецелом делении).
6. В main нужно создать и отправить в ExecutorService четыре задачи ScrollFragmentReader, каждая из которых отвечает за свою часть файла.
7. После завершения чтения каждая задача ScrollFragmentReader должна вывести в консоль сообщение строго по формату: "Собран фрагмент свитка с позиции [стартовая_позиция] размером [размер_фрагмента] байт!".
8. В методе main после отправки всех задач необходимо корректно завершить работу ExecutorService (например, вызвать shutdown() и дождаться завершения всех задач).