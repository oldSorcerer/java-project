
### Разгадываем тайны исключений: Иерархия Родителей

Представьте, что вы стали детективом по багам, и ваша задача — понять происхождение двух таинственных "проблем", которые возникли в вашей Java-программе. Одна из них связана с сетевым подключением, а другая — с внезапным исчезновением данных.

Ваше задание заключается в том, чтобы создать две переменные. Первую назовите networkProblem и пусть она будет представлять собой IOException, сигнализирующее о проблеме с вводом-выводом, например, когда сеть "отвалилась". Вторую переменную назовите missingDataError и пусть она будет представлять NullPointerException, указывающее на попытку использовать что-то, чего на самом деле нет.

Теперь, чтобы понять их происхождение, для каждой из этих "проблем" вам нужно узнать, кто их непосредственный родитель в иерархии исключений. Выведите на экран имя класса-родителя для каждой из них, используя специальные методы, которые позволяют заглянуть в родословную объекта.

#### Требования:
1. В программе должна быть объявлена переменная с именем networkProblem типа IOException.
2. В программе должна быть объявлена переменная с именем missingDataError типа NullPointerException.
3. Программа должна определить непосредственный родительский класс (superclass) для объекта networkProblem с помощью соответствующих методов класса Class.
4. Программа должна определить непосредственный родительский класс (superclass) для объекта missingDataError с помощью соответствующих методов класса Class.
5. Программа должна вывести на экран имя класса-родителя (superclass) для networkProblem и для missingDataError.