
### Отзывчивый пульт управления лазером ✨

Теперь, когда вы поняли последствия блокировки основного потока интерфейса при управлении лазером, пришло время исправить ситуацию и сделать ваш управляющий пульт по-настоящему отзывчивым.

Создайте новое Swing-приложение, похожее на предыдущее: JFrame с кнопкой "Огонь!" и текстовой меткой для отображения статуса, изначально показывающей "Ожидание команды".

Ключевое отличие будет в обработчике нажатия кнопки. Когда пользователь нажимает "Огонь!", вместо того чтобы замораживать весь интерфейс, вы должны запустить процесс зарядки лазера (вашу имитацию Thread.sleep(3000)) в совершенно отдельном потоке выполнения. Это позволит основному потоку интерфейса оставаться свободным и отзывчивым.

Однако, после того как зарядка лазера в фоновом потоке завершится, вам понадобится безопасно обновить статус на главной метке. Для этого используйте специальный инструмент Swing — SwingUtilities.invokeLater. Только внутри этого метода вы сможете изменить текст метки на "Лазер готов к выстрелу!", гарантируя, что обновление интерфейса произойдёт в правильном потоке.

Запустите это улучшенное приложение. Нажмите кнопку "Огонь!". Вы заметите, что окно останется полностью интерактивным во время "зарядки" лазера — вы сможете его перемещать, изменять размер, и метка обновится только после завершения фонового процесса, демонстрируя идеально отзывчивый интерфейс.

#### Требования:
1. Необходимо создать JFrame с кнопкой "Огонь!" и текстовой меткой, изначально отображающей "Ожидание команды".
2. При нажатии на кнопку "Огонь!" должен запускаться процесс зарядки лазера в отдельном потоке, чтобы не блокировать основной поток интерфейса.
3. В отдельном потоке должна быть реализована задержка с помощью Thread.sleep(3000), имитирующая зарядку лазера.
4. После завершения "зарядки" статус на метке должен быть изменён на "Лазер готов к выстрелу!" с помощью SwingUtilities.invokeLater.
5. Во время зарядки лазера окно приложения должно оставаться интерактивным: его можно перемещать, изменять размер и выполнять другие действия, связанные с пользовательским интерфейсом.
6. Процесс зарядки должен быть реализован именно в отдельном потоке, а не в основном (EDT), чтобы избежать блокировки интерфейса.