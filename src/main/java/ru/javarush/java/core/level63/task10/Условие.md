
### Капитан Кирк

Представьте себя капитаном космического корабля, и ваша система жизнеобеспечения (память) постоянно заполняется неизвестным, вязким веществом. Если не найти источник этого "загрязнителя" и не устранить его, корабль будет обречён. Вы используете VisualVM как свой космический сканер, чтобы найти и идентифицировать этого "захватчика".

Создайте Java-класс, внутри которого будет статическое поле типа ArrayList<byte[]>. В методе main запустите бесконечный цикл, который каждую секунду будет добавлять в этот список новый массив байт размером в 1 000 000 элементов. Запустите свою "программу-утечку". Пока она будет работать, откройте VisualVM, подключитесь к вашему процессу и сделайте heap dump – моментальный снимок всего содержимого памяти.

После этого критически важного "сканирования" вы должны будете определить, какой тип объекта стал основным "пожирателем" вашей драгоценной памяти, наглядно убедившись, что это именно ваш ArrayList<byte[]> и сами byte[] массивы, созданные им, которые заняли львиную долю доступной памяти.

#### Требования:
1. В классе должно быть объявлено статическое поле типа ArrayList<byte[]>.
2. Статическое поле ArrayList<byte[]> должно быть корректно инициализировано до начала использования.
3. В методе main должен быть реализован бесконечный цикл, в котором каждую секунду создается новый массив байт размером 1 000 000 элементов.
4. Каждый созданный массив должен добавляться в статический ArrayList<byte[]>.
5. Между добавлениями новых массивов должен соблюдаться интервал в 1 секунду (например, с помощью Thread.sleep).
6. Программа должна работать достаточно долго, чтобы можно было подключиться к ней через VisualVM и провести анализ памяти.
7. Программа должна создавать явную утечку памяти, чтобы при анализе heap dump в VisualVM было видно, что основными потребителями памяти являются объекты ArrayList<byte[]> и byte[].