
### Управление доступом к взлётно-посадочным полосам ✈️

Представьте, что вы — авиадиспетчер в очень оживлённом аэропорту, где доступно всего две взлётно-посадочные полосы (runwayCapacity). Многочисленные самолёты постоянно запрашивают разрешение на взлёт или посадку, но одновременно на полосах могут находиться только два из них.

Создайте класс AirTrafficController, который будет инкапсулировать эту логику. Внутри него должно быть поле типа Semaphore, инициализированное значением 2, что соответствует двум доступным полосам. Реализуйте метод manageRunwayAccess(String aircraftIdentifier): когда самолёт (идентифицируемый строкой aircraftIdentifier) запрашивает полосу, он должен сначала вызвать acquire(), чтобы получить разрешение. Как только доступ получен, выведите на экран сообщение "<aircraftIdentifier> получил разрешение на использование полосы". Затем сымитируйте использование полосы в течение 1 секунды, используя Thread.sleep(1000). По завершении операции самолёт должен вызвать release() и вывести сообщение "<aircraftIdentifier> освободил полосу".

В вашей основной программе, имитирующей работу диспетчерской вышки, запустите 4 потока, каждый из которых представляет отдельный самолёт и вызывает manageRunwayAccess с уникальным именем (например, "Рейс А1", "Рейс В2", "Рейс С3", "Рейс D4"). На консоли вы должны увидеть, что одновременно не появляется более двух сообщений о получении доступа, что наглядно демонстрирует контролируемый поток воздушного движения.

#### Требования:
1. Класс AirTrafficController должен содержать поле типа Semaphore, инициализированное значением 2, чтобы одновременно не более двух самолётов могли получить доступ к полосам.
2. В классе AirTrafficController должен быть реализован публичный метод manageRunwayAccess(String aircraftIdentifier), который инкапсулирует логику запроса и освобождения полосы.
3. В начале метода manageRunwayAccess необходимо вызвать метод acquire() у Semaphore, чтобы получить разрешение на использование полосы.
4. После получения разрешения на полосу, метод manageRunwayAccess должен вывести на экран сообщение "<aircraftIdentifier> получил разрешение на использование полосы".
5. После получения доступа метод manageRunwayAccess должен приостановить выполнение текущего потока на 1 секунду с помощью Thread.sleep(1000), имитируя использование полосы.
6. По завершении использования полосы метод manageRunwayAccess должен вызвать release() у Semaphore, чтобы освободить полосу.
7. После освобождения полосы метод manageRunwayAccess должен вывести на экран сообщение "<aircraftIdentifier> освободил полосу".
8. В основной программе должно быть создано и запущено четыре отдельных потока, каждый из которых вызывает manageRunwayAccess с уникальным значением aircraftIdentifier (например, "Рейс А1", "Рейс В2", "Рейс С3", "Рейс D4").
9. В консольном выводе не должно появляться более двух сообщений о получении доступа к полосе одновременно, что подтверждает корректную работу Semaphore и ограничения runwayCapacity.