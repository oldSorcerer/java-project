package ru.javarush.java.core.level64.task08;

import java.util.ArrayList;
import java.util.List;

/*
Задача: создать много объектов одного типа и подержать процесс "живым", чтобы посмотреть гистограмму классов через jmap.

Как использовать:
1) Компиляция и запуск (рекомендуем ограничить кучу):
   javac Solution.java
   java -Xms256m -Xmx256m Solution
   После старта программа выведет PID процесса.

2) Получение "инвентаризационной ведомости" (гистограмма классов):
   jmap -histo <PID>
   Пример: jmap -histo 12345
   (по желанию можно обрезать верхние строки: jmap -histo 12345 | head -n 30)

Результат моего анализа:
   Самым "памятистым" классом оказался [B (byte[]) — именно мы массово создаём эти массивы.
   На втором месте обычно идут java.lang.Object[] (внутренний буфер ArrayList) и другие служебные объекты JVM.
   Примечание: на современных JDK (9+) строки используют компактные байтовые массивы, поэтому при тестах со String
   лидером тоже часто оказывается [B.

Подсказка: PID можно узнать из вывода этой программы или командой jps -l.
*/

public class Solution {
    // Сколько массивов создаём (объектов одного типа)
    private static final int COUNT = 50_000; // 50 тыс. массивов
    // Размер каждого массива в байтах
    private static final int SIZE = 1024; // 1 КБ на массив

    public static void main(String[] args) throws InterruptedException {
        long pid = ProcessHandle.current().pid(); // Узнаём PID текущего процесса (Java 9+)
        System.out.println("PID процесса: " + pid);
        System.out.println("Создаю " + COUNT + " массивов byte[" + SIZE + "] (примерно " 
                + (COUNT * SIZE / (1024 * 1024)) + " МБ)...");

        // Хранилище для удержания ссылок на массивы, чтобы GC их не удалял
        List<byte[]> zoo = new ArrayList<>(COUNT);

        // Намеренно создаём много объектов одного типа — byte[]
        for (int i = 0; i < COUNT; i++) {
            zoo.add(new byte[SIZE]); // каждый новый массив занимает место в куче
            if ((i + 1) % 10_000 == 0) {
                System.out.println("Создано массивов: " + (i + 1));
            }
        }

        System.out.println("Готово. Объекты созданы и удерживаются в памяти.");
        System.out.println("Теперь можно выполнить в другом терминале: jmap -histo " + pid);

        // Бесконечный цикл — приложение не завершается, чтобы можно было анализировать память
        while (true) {
            Thread.sleep(60_000); // Спим минуту и снова — минимальная нагрузка на CPU
        }
    }
}