
### Эволюция каталога книг: что произойдёт с новыми полями?

Представьте, что вы управляете каталогом старинных книг, и каждая книга в вашей системе представлена простым классом Book. На начальном этапе этот класс был очень простым: он реализовывал интерфейс Serializable, чтобы книги можно было легко сохранять и восстанавливать, и содержал всего лишь одно поле — bookTitle типа String. Также, чтобы обеспечить контроль версий, у этого класса было статическое финальное поле serialVersionUID со значением 1L.

Теперь, спустя некоторое время, возникла необходимость улучшить ваш каталог. Вы хотите, чтобы для каждой книги сохранялась информация не только о её названии, но и об авторе. Поэтому вы решили добавить в класс Book новое поле bookAuthor типа String. При этом вы решили не менять значение serialVersionUID, чтобы сохранить совместимость со старыми сохранёнными данными.

#### Требования:
1. Класс Book должен реализовывать интерфейс Serializable для поддержки сериализации и десериализации объектов.
2. В классе Book должно быть объявлено поле bookTitle типа String.
3. В классе Book должно быть объявлено статическое финальное поле serialVersionUID со значением 1L.
4. В классе Book должно быть добавлено новое поле bookAuthor типа String.
5. После добавления поля bookAuthor значение поля serialVersionUID должно остаться равным 1L.
6. Класс Book после добавления нового поля должен корректно десериализовать объекты, сохранённые с предыдущей версией, где отсутствовало поле bookAuthor.
7. При десериализации старых объектов, в которых отсутствует поле bookAuthor, его значение должно быть установлено в null (значение по умолчанию для String).