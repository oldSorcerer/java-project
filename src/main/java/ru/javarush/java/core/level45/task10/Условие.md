
### Разработчик игры: оценка производительности сохранения инвентаря

Представьте, что вы — разработчик видеоигры, и вам предстоит сохранить огромный инвентарь игрока, состоящий из тысяч уникальных предметов. Вы хотите быть уверены, что процесс сохранения не займёт вечность и не испортит игровой опыт пользователя.

Для начала, создайте класс GameItem, который будет представлять собой один предмет инвентаря. Он должен быть Serializable и иметь два поля: itemId типа int для уникального идентификатора и itemName типа String для названия предмета.

Затем создайте огромный список playerInventory, который будет содержать 10 000 объектов GameItem. Важно, чтобы каждый предмет в этом списке имел уникальные значения itemId и itemName – это имитирует реалистичный игровой инвентарь.

Теперь самое интересное: вам нужно сериализовать этот playerInventory в файл с именем "items.bin". Для оптимизации производительности при работе с большим объёмом данных обязательно используйте BufferedOutputStream в сочетании с ObjectOutputStream.

Во время процесса сериализации, вам необходимо измерить, сколько времени это занимает. Для точного измерения используйте System.nanoTime() до и после операции записи. Затем преобразуйте полученное значение в миллисекунды и выведите его на экран. Это позволит вам оценить производительность сохранения большого объёма игровых данных и убедиться, что ваша система эффективно справляется с нагрузкой.

#### Требования:
1. Класс GameItem обязан реализовывать интерфейс Serializable для поддержки сериализации.
2. Класс GameItem должен содержать два поля: itemId типа int и itemName типа String.
3. Список playerInventory должен содержать 10 000 объектов GameItem, причём значения itemId и itemName у каждого объекта должны быть уникальными.
4. Для хранения инвентаря игрока необходимо использовать коллекцию типа List<GameItem>.
5. Для записи playerInventory в файл "items.bin" необходимо использовать ObjectOutputStream, обёрнутый в BufferedOutputStream.
6. Время сериализации должно измеряться с помощью System.nanoTime() непосредственно до и после записи playerInventory в файл.
7. Разница между двумя значениями System.nanoTime() должна быть преобразована в миллисекунды.
8. Полученное время сериализации в миллисекундах должно быть выведено на экран.