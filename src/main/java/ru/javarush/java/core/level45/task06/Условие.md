
### Генеалогическое древо: автоматическая миграция возраста

Представьте, что вы историк-генеалог, ведущий базу данных людей, и ваша программа хранит информацию о них. Изначально, в "первой версии" вашей программы, для каждого человека вы записывали год рождения в виде текстовой строки, используя класс Person с полем birthYearString типа String. Этот класс, конечно же, был Serializable, и имел serialVersionUID со значением 1L, чтобы вы могли сохранять и загружать свои данные.

Однако со временем вы обнаружили, что хранить год рождения строкой не очень удобно, а для анализа гораздо полезнее сразу иметь возраст человека. Поэтому во "второй версии" вашей программы вы приняли смелое решение: полностью удалить старое поле birthYearString из класса Person и вместо него добавить новое поле calculatedAge типа int. При этом, чтобы не нарушать совместимость со старыми файлами данных, вы предусмотрительно оставили serialVersionUID без изменений, всё те же 1L.

Теперь перед вами стоит сложная, но интересная задача: реализовать кастомную логику десериализации. Вам необходимо переопределить метод readObject в классе Person таким образом, чтобы при загрузке старых объектов (тех, что были сохранены до того, как вы изменили структуру класса), ваша программа могла "прочитать" устаревшее поле birthYearString и на его основе вычислить и присвоить значение новому полю calculatedAge. Например, вы можете определить возраст как 2024 - Integer.parseInt(birthYearString).

Конечная цель: ваша программа должна безупречно загружать как объекты, сериализованные старой версией класса Person, так и новой. При десериализации старых данных, поле calculatedAge должно корректно отображать возраст, вычисленный из birthYearString, обеспечивая плавный и автоматический переход к новой структуре данных. Это демонстрация того, как можно управлять миграцией данных при изменении схемы сериализации.

#### Требования:
1. Поле serialVersionUID класса Person должно иметь значение 1L и не изменяться между версиями класса.
2. В новой версии класса Person поле birthYearString типа String должно быть полностью удалено, а вместо него добавлено поле calculatedAge типа int.
3. В классе Person должен быть реализован приватный метод readObject(ObjectInputStream in), который корректно обрабатывает оба варианта сериализованных данных (старый и новый).
4. При десериализации объекта, сериализованного старой версией класса, метод readObject должен вручную извлекать значение поля birthYearString из потока.
5. Если при десериализации обнаружено поле birthYearString, метод readObject должен вычислять значение calculatedAge по формуле: 2024 - Integer.parseInt(birthYearString).
6. Если при десериализации объекта поле calculatedAge присутствует (файл сериализован новой версией), оно должно быть корректно восстановлено без дополнительных вычислений.
7. Десериализация должна работать как для объектов, сериализованных старой версией класса (с birthYearString), так и для объектов, сериализованных новой версией (с calculatedAge).
8. Класс Person должен реализовывать интерфейс Serializable, а все нестатические и неtransient поля, требующие сериализации, должны корректно сериализоваться и десериализоваться.
9. В случае невозможности преобразования birthYearString в целое число (например, некорректный формат), метод readObject должен корректно обрабатывать ошибку (например, выбрасывать исключение или устанавливать calculatedAge в значение по умолчанию).