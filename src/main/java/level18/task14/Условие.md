
### Корпоративная симфония: Полиморфизм в работе сотрудников

Представьте, что вы разрабатываете интеллектуальную систему для крупной компании, которая должна отслеживать деятельность своих сотрудников. Несмотря на разные должности, все они "работают".

Объявите базовый класс Employee с методом work(), который будет выводить на экран общую фразу: "Сотрудник работает...".

Теперь добавьте конкретные роли: Manager и Developer. Эти классы должны быть наследниками Employee и каждый из них должен переопределить метод work() так, чтобы он отражал их специфическую деятельность: Manager будет выводить "Менеджер проводит совещание.", а Developer — "Разработчик пишет код.".

В методе main соберите свою "команду" в один список. Для этого создайте массив, способный хранить объекты типа Employee. Добавьте в этот массив по одному объекту Manager и Developer. Затем пройдитесь по этому массиву с помощью цикла и для каждого члена команды вызовите метод work(). Ваша система должна четко показать, чем занимается каждый сотрудник, несмотря на то, что вы обращаетесь к ним как к обычным "сотрудникам".

#### Требования:
1. Должен быть создан класс Employee с методом work().
2. Метод work() в классе Employee должен выводить на экран строку "Сотрудник работает...".
3. Должны быть созданы классы Manager и Developer, которые наследуются от Employee.
4. Класс Manager должен переопределять метод work(), выводя строку "Менеджер проводит совещание.".
5. Класс Developer должен переопределять метод work(), выводя строку "Разработчик пишет код.".
6. В методе main должен быть создан массив, способный хранить объекты типа Employee.
7. В созданный массив должны быть добавлены по одному объекту классов Manager и Developer.
8. В методе main должен быть реализован цикл, проходящий по массиву сотрудников и вызывающий для каждого метод work().
9. Вызовы метода work() должны отражать полиморфное поведение: несмотря на тип Employee, должны выводиться специфические сообщения для Manager и Developer.