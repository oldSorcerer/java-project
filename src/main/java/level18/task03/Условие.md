
### Корпоративный лабиринт: Полиморфизм и роль сотрудника

Вы разрабатываете систему управления персоналом для крупной корпорации, где каждый сотрудник имеет свою уникальную роль, но при этом все они просто "работают". Создайте базовый класс Employee с методом void work(), который будет выводить на экран общую фразу: "Сотрудник работает.". Это будет стандартом для всех в вашей компании.

Теперь добавьте в компанию ключевого игрока — разработчика. Создайте класс Developer, который наследует от Employee. Разработчик, конечно, не просто "работает"; он пишет код! Поэтому переопределите метод work() в классе Developer так, чтобы он точно описывал его деятельность: "Разработчик пишет код.".

В методе main представьте, что вам поручили оценить работу одного из ваших сотрудников, но вы знаете его только как "общего" работника. Объявите переменную типа Employee. Затем, словно по волшебству, назначьте этой переменной объект Developer. Теперь вызовите метод work() у этой переменной. Ваша программа должна чётко показать, чем занимается этот сотрудник, выводя на экран: "Разработчик пишет код.". Это наглядно демонстрирует, как система, ориентированная на общую роль, все равно корректно вызывает специфическое поведение.

#### Требования:
1. В программе должен быть объявлен класс Employee с методом void work(), который выводит на экран "Сотрудник работает.".
2. Должен быть создан класс Developer, который наследуется от Employee.
3. В классе Developer метод work() должен быть переопределён и выводить на экран "Разработчик пишет код.".
4. В методе main необходимо объявить переменную типа Employee.
5. В переменную типа Employee должен быть присвоен объект класса Developer.
6. Метод work() должен быть вызван у переменной типа Employee, и результатом должен быть вывод "Разработчик пишет код.".
7. Программа должна наглядно показать, что при вызове переопределённого метода через ссылку базового типа вызывается реализация из подкласса.