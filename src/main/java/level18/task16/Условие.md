
### Динамичный офис: Расширяемость и универсальность полиморфизма

Представьте, что вы создаете централизованную систему управления задачами для быстрорастущей и постоянно меняющейся компании. Вам нужна система, которая сможет легко адаптироваться к новым типам сотрудников без необходимости переписывать основной код.

Начните с создания классов Employee, Manager, Developer и Designer. Все они должны содержать метод work(): Manager выводит "Менеджер проводит совещание.", Developer — "Разработчик пишет код.", Designer — "Дизайнер рисует макеты.", а базовый Employee — "Сотрудник работает...".

В методе main соберите ваш текущий штат. Создайте массив типа Employee и добавьте в него по одному объекту каждого из этих классов. Затем напишите цикл, который вызывает work() для каждого элемента массива, демонстрируя их деятельность.

**Теперь самое интересное**: компания наняла нового сотрудника — стажёра! Добавьте новый класс Intern, который наследуется от Employee и выводит "Стажёр учится работать." в своём методе work(). Добавьте объект Intern в тот же самый массив, который вы создали ранее, и снова вызовите work() для всех сотрудников в массиве, используя ваш существующий цикл. Программа должна абсолютно корректно и без единого изменения в уже написанном коде (кроме добавления нового объекта в массив) справиться с новым типом сотрудника, демонстрируя истинную силу полиморфизма.

#### Требования:
1. Должен быть создан базовый класс Employee с методом work(), который выводит "Сотрудник работает...".
2. Должны быть созданы классы Manager, Developer и Designer, каждый из которых наследуется от Employee и переопределяет метод work() с уникальным сообщением: Manager — "Менеджер проводит совещание." Developer — "Разработчик пишет код." Designer — "Дизайнер рисует макеты."
3. В методе main должен быть создан массив типа Employee, в который добавляются объекты классов Employee, Manager, Developer и Designer.
4. В main должен быть реализован цикл, который проходит по массиву Employee и вызывает метод work() для каждого элемента, корректно отображая деятельность каждого сотрудника.
5. Должен быть создан новый класс Intern, наследующийся от Employee и переопределяющий метод work() с выводом "Стажёр учится работать.".
6. Объект Intern должен быть добавлен в тот же массив сотрудников, и существующий цикл вызова work() должен корректно обработать новый тип сотрудника без изменения логики вызова методов.
7. Программа должна демонстрировать, что добавление новых типов сотрудников (наследников Employee) не требует изменений в основной логике обработки коллекции сотрудников.